<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HIVTRUCK</title>

    <!-- Icons in tab -->
    <link rel="icon" type="image/x-icon" href="images/icons/favicon.ico" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="images/icons/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="images/icons/favicon-16x16.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="images/icons/apple-touch-icon.png"
    />

    <link rel="stylesheet" href="style.css" />

    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <meta name="color-scheme" content="dark" />
    <meta name="theme-color" content="#2c3e50" />

    <!-- Add after existing meta tags -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Segoe+UI:wght@300;400&display=swap"
      rel="stylesheet"
    />

    <!-- Add Masonry library before closing head -->
    <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
    <script src="https://unpkg.com/imagesloaded@5/imagesloaded.pkgd.min.js"></script>
  </head>

  <body>
    <div class="parallax-container">
      <div class="parallax-layer layer-skybox"></div>
      <div class="parallax-layer layer-foreground"></div>
    </div>
    <div class="aero-wrapper">
      <div class="container">
        <h1 class="title">HIVTRUCK</h1>

        <div class="image-wrapper">
          <img src="images/art1.jpg" class="d-block w-100" alt="Art Piece 1" />
        </div>

        <!-- Buttons after the carousel -->
        <div class="action-buttons text-center">
          <!-- Telegram Button -->
          <a
            href="https://t.me/funnyhivtruck"
            class="btn btn-telegram btn-custom"
            target="_blank"
            rel="noopener noreferrer"
          >
            <i class="fab fa-telegram"></i>
          </a>

          <!-- Email Button -->
          <a href="mailto:hivtruck@proton.me" class="btn btn-email btn-custom">
            <i class="fas fa-envelope"></i>
          </a>
        </div>
      </div>
      <div class="secondary-container">
        <div class="grid-gallery" data-masonry='{ "itemSelector": ".grid-item", "columnWidth": ".grid-sizer", "percentPosition": true }'>
            <div class="grid-sizer"></div>
            <!-- Grid items will be dynamically generated by JavaScript -->
        </div>
      </div>
    </div>
    <div class="fullscreen-viewer">
        <div class="viewer-content">
            <img src="" alt="Full view image">
            <button class="close-viewer">
                <i class="fas fa-times"></i>
            </button>
            <button class="nav-btn prev-btn">
                <i class="fas fa-chevron-left"></i>
            </button>
            <button class="nav-btn next-btn">
                <i class="fas fa-chevron-right"></i>
            </button>
        </div>
    </div>
    <script>
      const imageList = [
        'images/art1.jpg'
      ];
      let currentImageIndex = 0;

      const parallaxLayers = document.querySelectorAll('.parallax-layer');
    
      document.addEventListener('mousemove', (e) => {
          const mouseX = e.clientX / window.innerWidth;
          const mouseY = e.clientY / window.innerHeight;

          parallaxLayers.forEach((layer, index) => {
              const isForeground = layer.classList.contains('layer-foreground');
              const speedX = isForeground ? 15 : 30;
              const speedY = isForeground ? 5 : 10;
              
              // Calculate movement based on viewport size
              const x = mouseX * speedX * (window.innerWidth / 1920);
              const y = mouseY * speedY * (window.innerHeight / 1080);
              
              layer.style.transform = `translate3d(${-x}px, ${-y}px, 0)`;
          });
      });

      window.addEventListener('resize', () => {
          const foreground = document.querySelector('.layer-foreground');
          foreground.style.transform = 'translate3d(0, 0, 0)'; // Reset transform on resize
      });

      const img = document.querySelector("img");
      const container = document.querySelector(".container");
      let currentRotateX = 0;
      let currentRotateY = 0;
      let currentScale = 1;
      let isAnimating = false;

      // Image animation
      container.addEventListener("mousemove", (e) => {
        const imgRect = img.getBoundingClientRect();
        const x = e.clientX - imgRect.left;
        const y = e.clientY - imgRect.top;

        const buffer = 40;
        const isInside =
          x >= buffer &&
          x <= imgRect.width - buffer &&
          y >= buffer &&
          y <= imgRect.height - buffer;

        const centerX = imgRect.width / 2;
        const centerY = imgRect.height / 2;

        if (isInside) {
          const targetRotateX = -((y - centerY) / centerY) * 5;
          const targetRotateY = ((x - centerX) / centerX) * 5;

          currentRotateX += (targetRotateX - currentRotateX) * 0.1;
          currentRotateY += (targetRotateY - currentRotateY) * 0.1;
          currentScale += (1.01 - currentScale) * 0.1;
        } else {
          currentRotateX *= 0.9;
          currentRotateY *= 0.9;
          currentScale += (1 - currentScale) * 0.1;
        }

        if (!isAnimating) {
          isAnimating = true;
          requestAnimationFrame(animateImage);
        }
      });

      function animateImage() {
        img.style.transform = `
            perspective(1000px) 
            rotateX(${currentRotateX}deg) 
            rotateY(${currentRotateY}deg) 
            scale3d(${currentScale}, ${currentScale}, ${currentScale})
        `;

        if (
          Math.abs(currentRotateX) > 0.01 ||
          Math.abs(currentRotateY) > 0.01 ||
          Math.abs(currentScale - 1) > 0.001
        ) {
          requestAnimationFrame(animateImage);
        } else {
          isAnimating = false;
        }
      }

      // Button animations
      const buttons = document.querySelectorAll(".btn-custom");

      buttons.forEach((btn) => {
        let btnRotateX = 0;
        let btnRotateY = 0;
        let btnScale = 1;
        let btnAnimating = false;

        container.addEventListener("mousemove", (e) => {
          const btnRect = btn.getBoundingClientRect();
          const x = e.clientX - btnRect.left;
          const y = e.clientY - btnRect.top;

          // Calculate proportional buffer (40px for 400px image = 10% of size)
          const buffer = btnRect.width * 0.1; // 10% of button width
          const isInside =
            x >= buffer &&
            x <= btnRect.width - buffer &&
            y >= buffer &&
            y <= btnRect.height - buffer;

          const centerX = btnRect.width / 2;
          const centerY = btnRect.height / 2;

          if (isInside) {
            const rotateX = -((y - centerY) / centerY) * 15;
            const rotateY = ((x - centerX) / centerX) * 15;

            btnRotateX += (rotateX - btnRotateX) * 0.2;
            btnRotateY += (rotateY - btnRotateY) * 0.2;
            btnScale += (1.05 - btnScale) * 0.15;
          } else {
            btnRotateX *= 0.85;
            btnRotateY *= 0.85;
            btnScale += (1 - btnScale) * 0.15;
          }

          if (!btnAnimating) {
            btnAnimating = true;
            animateButton();
          }

          function animateButton() {
            btn.style.transform = `
                    perspective(1000px) 
                    rotateX(${btnRotateX}deg) 
                    rotateY(${btnRotateY}deg) 
                    scale3d(${btnScale}, ${btnScale}, ${btnScale})
                `;

            if (
              Math.abs(btnRotateX) > 0.01 ||
              Math.abs(btnRotateY) > 0.01 ||
              Math.abs(btnScale - 1) > 0.001
            ) {
              requestAnimationFrame(animateButton);
            } else {
              btnAnimating = false;
            }
          }
        });

        container.addEventListener("mouseleave", () => {
          btnRotateX = 0;
          btnRotateY = 0;
          btnScale = 1;
          btn.style.transform =
            "perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)";
        });
      });

      // Add color detection
      function getAverageColor(img) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = img.width;
        canvas.height = img.height;

        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(
          0,
          0,
          canvas.width,
          canvas.height
        ).data;

        let r = 0,
          g = 0,
          b = 0,
          count = 0;

        for (let i = 0; i < imageData.length; i += 4) {
          r += imageData[i];
          g += imageData[i + 1];
          b += imageData[i + 2];
          count++;
        }

        return {
          r: Math.round(r / count),
          g: Math.round(g / count),
          b: Math.round(b / count),
        };
      }

      const images = document.querySelectorAll("img");
      images.forEach((img) => {
        img.onload = () => {
          const color = getAverageColor(img);
          const wrapper = img.closest(".image-wrapper");
          wrapper.style.setProperty(
            "--dominant-color",
            `${color.r}, ${color.g}, ${color.b}`
          );
        };
      });

      const mainImage = document.querySelector('.image-wrapper img');
      mainImage.addEventListener('click', () => {
          openViewer(currentImageIndex);
      });

      // Remove the duplicate DOMContentLoaded event listeners and replace with this single version
      document.addEventListener('DOMContentLoaded', () => {
        const gallery = document.querySelector('.grid-gallery');
        const viewer = document.querySelector('.fullscreen-viewer');
        const viewerImg = viewer.querySelector('.viewer-content img');
        const closeBtn = viewer.querySelector('.close-viewer');
        const prevBtn = viewer.querySelector('.prev-btn');
        const nextBtn = viewer.querySelector('.next-btn');
        const mainImage = document.querySelector('.image-wrapper img');
        const imageCount = 25;
        const startIndex = 2;  // Changed from 4 to 2 to include art2.jpg and art3.jpg
        let currentViewerIndex = 0;
        let gridImages = [];
        let msnry;

        // Add main carousel images to gridImages
        imageList.forEach(img => gridImages.push(img));

        // Function to create and append grid items
        function createGridItem(index) {
            const gridItem = document.createElement('div');
            gridItem.className = 'grid-item';
            
            const img = document.createElement('img');
            img.src = `images/art${index}.jpg`;
            img.alt = `Art ${index}`;
            img.loading = 'lazy';
            
            gridItem.appendChild(img);
            gallery.appendChild(gridItem);
            gridImages.push(img.src);

            // Add click handler to each grid item
            gridItem.addEventListener('click', () => {
                openViewer(gridImages.indexOf(img.src));
            });

            // Layout Masonry after each image loads
            img.onload = () => {
                if (msnry) {
                    msnry.layout();
                }
            };
        }

        // Update Masonry initialization
        function initMasonry() {
            // Create grid items
            for (let i = startIndex; i <= imageCount; i++) {
                createGridItem(i);
            }

            imagesLoaded(gallery, () => {
                msnry = new Masonry(gallery, {
                    itemSelector: '.grid-item',
                    columnWidth: '.grid-sizer',
                    percentPosition: true,
                    gutter: 20, // Increased gutter spacing
                    transitionDuration: '0.3s'
                });

                // Relayout Masonry periodically to handle any layout issues
                setTimeout(() => msnry.layout(), 1000);
            });
        }

        // Add window resize handler
        window.addEventListener('resize', () => {
            if (msnry) {
                msnry.layout();
            }
        });

        initMasonry();

        // Function to open viewer
        function openViewer(index) {
            currentViewerIndex = index;
            viewer.style.display = 'flex';
            viewerImg.src = gridImages[currentViewerIndex];
            
            requestAnimationFrame(() => {
                viewer.classList.add('active');
            });
            document.body.style.overflow = 'hidden';
        }

        // Add click handler for main image
        mainImage.addEventListener('click', () => {
            openViewer(currentImageIndex);
        });

        // Function to close viewer
        function closeViewer() {
            viewer.classList.remove('active');
            setTimeout(() => {
                viewer.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
        }

        // Function to navigate images
        function navigateImages(direction) {
            viewerImg.style.opacity = '0';
            viewerImg.style.transform = 'scale(0.95)';
            
            setTimeout(() => {
                currentViewerIndex = (currentViewerIndex + direction + gridImages.length) % gridImages.length;
                viewerImg.src = gridImages[currentViewerIndex];
                
                // Update main image if we're viewing the first image
                if (currentViewerIndex === 0) {
                    currentImageIndex = currentViewerIndex;
                    mainImage.src = imageList[currentImageIndex];
                    // Update color detection for main image
                    const wrapper = mainImage.closest(".image-wrapper");
                    const img = new Image();
                    img.onload = () => {
                        const color = getAverageColor(img);
                        wrapper.style.setProperty(
                            "--dominant-color",
                            `${color.r}, ${color.g}, ${color.b}`
                        );
                    };
                    img.src = mainImage.src;
                }
                
                requestAnimationFrame(() => {
                    viewerImg.style.opacity = '1';
                    viewerImg.style.transform = 'scale(1)';
                });
            }, 150);
        }

        // Event listeners
        closeBtn.addEventListener('click', closeViewer);
        prevBtn.addEventListener('click', () => navigateImages(-1));
        nextBtn.addEventListener('click', () => navigateImages(1));

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (!viewer.classList.contains('active')) return;
            
            switch(e.key) {
                case 'Escape':
                    closeViewer();
                    break;
                case 'ArrowLeft':
                    navigateImages(-1);
                    break;
                case 'ArrowRight':
                    navigateImages(1);
                    break;
            }
        });

        // Handle image load errors
        viewerImg.addEventListener('error', () => {
            console.error('Failed to load image:', viewerImg.src);
            closeViewer();
        });
    });
    </script>
  </body>
</html>
