<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HIVTRUCK</title>

    <!-- Icons in tab -->
    <link rel="icon" type="image/x-icon" href="images/icons/favicon.ico" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="images/icons/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="images/icons/favicon-16x16.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="images/icons/apple-touch-icon.png"
    />

    <link rel="stylesheet" href="style.css" />

    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <meta name="color-scheme" content="dark" />
    <meta name="theme-color" content="#2c3e50" />

    <!-- Add after existing meta tags -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Segoe+UI:wght@300;400&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <div class="parallax-container">
      <div class="parallax-layer layer-skybox"></div>
      <div class="parallax-layer layer-foreground"></div>
    </div>
    <div class="aero-wrapper">
      <div class="container">
        <h1 class="title">HIVTRUCK</h1>

        <div class="image-wrapper">
          <img src="images/art1.jpg" class="d-block w-100" alt="Art Piece 1" />
        </div>

        <!-- Buttons after the carousel -->
        <div class="action-buttons text-center">
          <!-- Telegram Button -->
          <a
            href="https://t.me/funnyhivtruck"
            class="btn btn-telegram btn-custom"
            target="_blank"
            rel="noopener noreferrer"
          >
            <i class="fab fa-telegram"></i>
          </a>

          <!-- Email Button -->
          <a href="mailto:hivtruck@proton.me" class="btn btn-email btn-custom">
            <i class="fas fa-envelope"></i>
          </a>
        </div>
      </div>
      <div class="secondary-container">
        <div class="grid-gallery">
            <!-- Prototype grid items -->
            <div class="grid-item">
                <img src="images/art1.jpg" alt="Art 1">
            </div>
            <div class="grid-item">
                <img src="images/art1.jpg" alt="Art 2">
            </div>
            <div class="grid-item">
                <img src="images/art1.jpg" alt="Art 3">
            </div>
            <div class="grid-item">
                <img src="images/art1.jpg" alt="Art 4">
            </div>
            <div class="grid-item">
                <img src="images/art1.jpg" alt="Art 5">
            </div>
            <div class="grid-item">
                <img src="images/art1.jpg" alt="Art 6">
            </div>
            <div class="grid-item">
                <img src="images/art1.jpg" alt="Art 7">
            </div>
            <div class="grid-item">
                <img src="images/art1.jpg" alt="Art 8">
            </div>
        </div>
      </div>
    </div>
    <div class="fullscreen-viewer">
        <div class="viewer-content">
            <img src="" alt="Full view image">
            <button class="close-viewer">
                <i class="fas fa-times"></i>
            </button>
            <button class="nav-btn prev-btn">
                <i class="fas fa-chevron-left"></i>
            </button>
            <button class="nav-btn next-btn">
                <i class="fas fa-chevron-right"></i>
            </button>
        </div>
    </div>
    <script>
      const imageList = [
        'images/art1.jpg',
        'images/art2.jpg',
        'images/art3.jpg'
      ];
      let currentImageIndex = 0;

      const parallaxLayers = document.querySelectorAll('.parallax-layer');
    
      document.addEventListener('mousemove', (e) => {
          const mouseX = e.clientX / window.innerWidth;
          const mouseY = e.clientY / window.innerHeight;

          parallaxLayers.forEach((layer, index) => {
              const isForeground = layer.classList.contains('layer-foreground');
              const speedX = isForeground ? 15 : 30;
              const speedY = isForeground ? 5 : 10;
              
              // Calculate movement based on viewport size
              const x = mouseX * speedX * (window.innerWidth / 1920);
              const y = mouseY * speedY * (window.innerHeight / 1080);
              
              layer.style.transform = `translate3d(${-x}px, ${-y}px, 0)`;
          });
      });

      window.addEventListener('resize', () => {
          const foreground = document.querySelector('.layer-foreground');
          foreground.style.transform = 'translate3d(0, 0, 0)'; // Reset transform on resize
      });

      const img = document.querySelector("img");
      const container = document.querySelector(".container");
      let currentRotateX = 0;
      let currentRotateY = 0;
      let currentScale = 1;
      let isAnimating = false;

      // Image animation
      container.addEventListener("mousemove", (e) => {
        const imgRect = img.getBoundingClientRect();
        const x = e.clientX - imgRect.left;
        const y = e.clientY - imgRect.top;

        const buffer = 40;
        const isInside =
          x >= buffer &&
          x <= imgRect.width - buffer &&
          y >= buffer &&
          y <= imgRect.height - buffer;

        const centerX = imgRect.width / 2;
        const centerY = imgRect.height / 2;

        if (isInside) {
          const targetRotateX = -((y - centerY) / centerY) * 5;
          const targetRotateY = ((x - centerX) / centerX) * 5;

          currentRotateX += (targetRotateX - currentRotateX) * 0.1;
          currentRotateY += (targetRotateY - currentRotateY) * 0.1;
          currentScale += (1.01 - currentScale) * 0.1;
        } else {
          currentRotateX *= 0.9;
          currentRotateY *= 0.9;
          currentScale += (1 - currentScale) * 0.1;
        }

        if (!isAnimating) {
          isAnimating = true;
          requestAnimationFrame(animateImage);
        }
      });

      function animateImage() {
        img.style.transform = `
            perspective(1000px) 
            rotateX(${currentRotateX}deg) 
            rotateY(${currentRotateY}deg) 
            scale3d(${currentScale}, ${currentScale}, ${currentScale})
        `;

        if (
          Math.abs(currentRotateX) > 0.01 ||
          Math.abs(currentRotateY) > 0.01 ||
          Math.abs(currentScale - 1) > 0.001
        ) {
          requestAnimationFrame(animateImage);
        } else {
          isAnimating = false;
        }
      }

      // Button animations
      const buttons = document.querySelectorAll(".btn-custom");

      buttons.forEach((btn) => {
        let btnRotateX = 0;
        let btnRotateY = 0;
        let btnScale = 1;
        let btnAnimating = false;

        container.addEventListener("mousemove", (e) => {
          const btnRect = btn.getBoundingClientRect();
          const x = e.clientX - btnRect.left;
          const y = e.clientY - btnRect.top;

          // Calculate proportional buffer (40px for 400px image = 10% of size)
          const buffer = btnRect.width * 0.1; // 10% of button width
          const isInside =
            x >= buffer &&
            x <= btnRect.width - buffer &&
            y >= buffer &&
            y <= btnRect.height - buffer;

          const centerX = btnRect.width / 2;
          const centerY = btnRect.height / 2;

          if (isInside) {
            const rotateX = -((y - centerY) / centerY) * 15;
            const rotateY = ((x - centerX) / centerX) * 15;

            btnRotateX += (rotateX - btnRotateX) * 0.2;
            btnRotateY += (rotateY - btnRotateY) * 0.2;
            btnScale += (1.05 - btnScale) * 0.15;
          } else {
            btnRotateX *= 0.85;
            btnRotateY *= 0.85;
            btnScale += (1 - btnScale) * 0.15;
          }

          if (!btnAnimating) {
            btnAnimating = true;
            animateButton();
          }

          function animateButton() {
            btn.style.transform = `
                    perspective(1000px) 
                    rotateX(${btnRotateX}deg) 
                    rotateY(${btnRotateY}deg) 
                    scale3d(${btnScale}, ${btnScale}, ${btnScale})
                `;

            if (
              Math.abs(btnRotateX) > 0.01 ||
              Math.abs(btnRotateY) > 0.01 ||
              Math.abs(btnScale - 1) > 0.001
            ) {
              requestAnimationFrame(animateButton);
            } else {
              btnAnimating = false;
            }
          }
        });

        container.addEventListener("mouseleave", () => {
          btnRotateX = 0;
          btnRotateY = 0;
          btnScale = 1;
          btn.style.transform =
            "perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)";
        });
      });

      // Add color detection
      function getAverageColor(img) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = img.width;
        canvas.height = img.height;

        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(
          0,
          0,
          canvas.width,
          canvas.height
        ).data;

        let r = 0,
          g = 0,
          b = 0,
          count = 0;

        for (let i = 0; i < imageData.length; i += 4) {
          r += imageData[i];
          g += imageData[i + 1];
          b += imageData[i + 2];
          count++;
        }

        return {
          r: Math.round(r / count),
          g: Math.round(g / count),
          b: Math.round(b / count),
        };
      }

      const images = document.querySelectorAll("img");
      images.forEach((img) => {
        img.onload = () => {
          const color = getAverageColor(img);
          const wrapper = img.closest(".image-wrapper");
          wrapper.style.setProperty(
            "--dominant-color",
            `${color.r}, ${color.g}, ${color.b}`
          );
        };
      });

      const mainImage = document.querySelector('.image-wrapper img');
      mainImage.addEventListener('click', () => {
          
          isAnimating = true;
          currentScale = 0.8; // Shrink
          
          setTimeout(() => {
              currentImageIndex = (currentImageIndex + 1) % imageList.length;
              mainImage.src = imageList[currentImageIndex];
              currentScale = 1.1; // Slightly larger than normal
              
              setTimeout(() => {
                  currentScale = 1; // Back to normal size
                  isAnimating = false;
              }, 150);
          }, 150);
      });

      // Add fullscreen viewer functionality
      document.addEventListener('DOMContentLoaded', () => {
        const viewer = document.querySelector('.fullscreen-viewer');
        const viewerImg = viewer.querySelector('img');
        const closeBtn = viewer.querySelector('.close-viewer');
        const prevBtn = viewer.querySelector('.prev-btn');
        const nextBtn = viewer.querySelector('.next-btn');
        const gridItems = document.querySelectorAll('.grid-item img');
        let currentViewerIndex = 0;

        // Convert grid items to array for easy navigation
        const gridImages = Array.from(gridItems).map(img => img.src);

        // Open viewer
        gridItems.forEach((img, index) => {
            img.addEventListener('click', () => {
                currentViewerIndex = index;
                viewerImg.src = img.src;
                viewer.classList.add('active');
                document.body.style.overflow = 'hidden';
            });
        });

        // Close viewer
        closeBtn.addEventListener('click', () => {
            viewer.classList.remove('active');
            document.body.style.overflow = '';
        });

        // Navigate images
        prevBtn.addEventListener('click', () => {
            currentViewerIndex = (currentViewerIndex - 1 + gridImages.length) % gridImages.length;
            viewerImg.src = gridImages[currentViewerIndex];
        });

        nextBtn.addEventListener('click', () => {
            currentViewerIndex = (currentViewerIndex + 1) % gridImages.length;
            viewerImg.src = gridImages[currentViewerIndex];
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (!viewer.classList.contains('active')) return;
            
            if (e.key === 'Escape') {
                viewer.classList.remove('active');
                document.body.style.overflow = '';
            }
            if (e.key === 'ArrowLeft') prevBtn.click();
            if (e.key === 'ArrowRight') nextBtn.click();
        });
      });

      // Update the viewer functionality
      document.addEventListener('DOMContentLoaded', () => {
        const viewer = document.querySelector('.fullscreen-viewer');
        const viewerImg = viewer.querySelector('img');
        const closeBtn = viewer.querySelector('.close-viewer');
        const prevBtn = viewer.querySelector('.prev-btn');
        const nextBtn = viewer.querySelector('.next-btn');
        const gridItems = document.querySelectorAll('.grid-item img');
        let currentViewerIndex = 0;

        const gridImages = Array.from(gridItems).map(img => img.src);

        // Open viewer with animation
        gridItems.forEach((img, index) => {
            img.addEventListener('click', () => {
                currentViewerIndex = index;
                viewer.style.display = 'flex';
                viewerImg.src = img.src;
                
                // Trigger animation
                requestAnimationFrame(() => {
                    viewer.classList.add('active');
                });
                
                document.body.style.overflow = 'hidden';
            });
        });

        // Close viewer with animation
        closeBtn.addEventListener('click', closeViewer);

        function closeViewer() {
            viewer.classList.remove('active');
            
            // Wait for animation to complete before hiding
            setTimeout(() => {
                viewer.style.display = 'none';
                document.body.style.overflow = '';
            }, 300); // Match the transition duration
        }

        // Update navigation to handle animations
        function navigateImages(direction) {
            viewerImg.style.opacity = '0';
            viewerImg.style.transform = 'scale(0.95)';
            
            setTimeout(() => {
                currentViewerIndex = (currentViewerIndex + direction + gridImages.length) % gridImages.length;
                viewerImg.src = gridImages[currentViewerIndex];
                
                requestAnimationFrame(() => {
                    viewerImg.style.opacity = '1';
                    viewerImg.style.transform = 'scale(1)';
                });
            }, 150);
        }

        prevBtn.addEventListener('click', () => navigateImages(-1));
        nextBtn.addEventListener('click', () => navigateImages(1));

        // Update keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (!viewer.classList.contains('active')) return;
            
            if (e.key === 'Escape') closeViewer();
            if (e.key === 'ArrowLeft') navigateImages(-1);
            if (e.key === 'ArrowRight') navigateImages(1);
        });
    });
    </script>
  </body>
</html>
